name: Build and Test Multi-Arch

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

env:
  CARGO_TERM_COLOR: always
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  test-native:
    name: Test on ${{ matrix.os }}
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest]
        rust: [stable]

    steps:
    - uses: actions/checkout@v3

    - name: Setup Rust
      uses: actions-rs/toolchain@v1
      with:
        profile: minimal
        toolchain: ${{ matrix.rust }}
        override: true

    - name: Install dependencies (Linux)
      if: runner.os == 'Linux'
      run: |
        sudo apt-get update
        sudo apt-get install -y libturbojpeg0-dev pkg-config

    - name: Cache cargo registry
      uses: actions/cache@v3
      with:
        path: ~/.cargo/registry
        key: ${{ runner.os }}-cargo-registry-${{ hashFiles('**/Cargo.lock') }}

    - name: Cache cargo index
      uses: actions/cache@v3
      with:
        path: ~/.cargo/git
        key: ${{ runner.os }}-cargo-index-${{ hashFiles('**/Cargo.lock') }}

    - name: Cache cargo build
      uses: actions/cache@v3
      with:
        path: server/target
        key: ${{ runner.os }}-cargo-build-target-${{ hashFiles('**/Cargo.lock') }}

    - name: Run tests
      working-directory: ./server
      run: |
        cargo test --verbose
        cargo test --release

    - name: Run clippy
      working-directory: ./server
      run: cargo clippy -- -D warnings

  build-multi-arch:
    name: Build Multi-Arch Docker Image
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Set up QEMU
      uses: docker/setup-qemu-action@v2

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v2

    - name: Login to GitHub Container Registry
      uses: docker/login-action@v2
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v4
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=semver,pattern={{version}}
          type=semver,pattern={{major}}.{{minor}}
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}

    - name: Build and push multi-platform image
      uses: docker/build-push-action@v4
      with:
        context: ./server
        platforms: linux/amd64,linux/arm64
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        # Build args for optimization
        build-args: |
          RUSTFLAGS=-C target-cpu=native -C opt-level=3 -C lto=fat

  benchmark:
    name: Performance Benchmark - ${{ matrix.arch }}
    needs: build-multi-arch
    runs-on: ${{ matrix.runner }}
    strategy:
      matrix:
        include:
          - arch: amd64
            runner: ubuntu-latest
            platform: linux/amd64
          - arch: arm64
            runner: ubuntu-latest  # Will use QEMU for ARM64
            platform: linux/arm64

    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Set up QEMU
      if: matrix.arch == 'arm64'
      uses: docker/setup-qemu-action@v2
      with:
        platforms: arm64

    - name: Login to GitHub Container Registry
      uses: docker/login-action@v2
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Pull ${{ matrix.arch }} image
      run: |
        docker pull --platform ${{ matrix.platform }} \
          ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}

    - name: Download test data
      run: |
        # Download pre-created test data archive
        # Option 1: From GitHub Release (replace with your release URL)
        # curl -L https://github.com/${{ github.repository }}/releases/download/test-data/test-data.tar.gz -o test-data.tar.gz

        # Option 2: From artifact storage (e.g., S3, GCS)
        # aws s3 cp s3://your-bucket/test-data.tar.gz test-data.tar.gz

        # Option 3: Create minimal test data on the fly (fastest for CI)
        mkdir -p test-data/demo_out
        echo '{"levels": 16, "tileSize": 256, "width": 65536, "height": 65536}' > test-data/demo_out/baseline_pyramid.dzi

        # For now, we'll extract if archive exists locally
        if [ -f "${{ github.workspace }}/server/test-data.tar.gz" ]; then
          tar -xzf ${{ github.workspace }}/server/test-data.tar.gz -C test-data/
        fi

    - name: Run performance tests on ${{ matrix.arch }}
      run: |
        # Create results file
        RESULTS_FILE="perf-results-${{ matrix.arch }}.txt"
        echo "=== Performance Test Results for ${{ matrix.arch }} ===" > $RESULTS_FILE
        echo "Timestamp: $(date -u +"%Y-%m-%d %H:%M:%S UTC")" >> $RESULTS_FILE
        echo "Git SHA: ${{ github.sha }}" >> $RESULTS_FILE
        echo "Platform: ${{ matrix.platform }}" >> $RESULTS_FILE
        echo "" >> $RESULTS_FILE

        # Start the server with test data
        docker run -d --name origami-server-${{ matrix.arch }} \
          --platform ${{ matrix.platform }} \
          -p 8080:8080 \
          -v ${{ github.workspace }}/test-data:/data \
          ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }} \
          --timing-breakdown

        # Wait for server to be ready
        sleep 10  # Extra time for QEMU if ARM64

        # Check if server is healthy
        for i in {1..10}; do
          if curl -f http://localhost:8080/healthz; then
            echo "Server is ready" | tee -a $RESULTS_FILE
            break
          fi
          echo "Waiting for server... attempt $i"
          sleep 2
        done

        # Warm up cache
        echo "=== Warming up cache ===" | tee -a $RESULTS_FILE
        for i in {1..5}; do
          curl -s http://localhost:8080/tiles/demo_out/14/100_100.jpg > /dev/null
        done

        # Run timing tests and log results
        echo "" >> $RESULTS_FILE
        echo "=== Individual Request Timings ===" | tee -a $RESULTS_FILE

        # Collect timing data
        TIMES=""
        for i in {1..20}; do
          TIME=$(curl -s -o /dev/null -w "%{time_total}" http://localhost:8080/tiles/demo_out/14/100_100.jpg)
          TIMES="$TIMES $TIME"
          echo "Request $i: ${TIME}s" >> $RESULTS_FILE
        done

        # Calculate statistics
        echo "" >> $RESULTS_FILE
        echo "=== Statistics ===" | tee -a $RESULTS_FILE
        echo "$TIMES" | awk '{
          min = max = sum = $1;
          for (i = 1; i <= NF; i++) {
            sum += $i;
            if ($i < min) min = $i;
            if ($i > max) max = $i;
          }
          avg = sum / NF;
          print "Min: " min "s";
          print "Max: " max "s";
          print "Avg: " avg "s";
          print "Samples: " NF;
        }' | tee -a $RESULTS_FILE

        # If wrk is available, run load test (only on native arch)
        if [ "${{ matrix.arch }}" = "amd64" ]; then
          echo "" >> $RESULTS_FILE
          echo "=== Load Test Results (wrk) ===" | tee -a $RESULTS_FILE
          docker run --rm --network host \
            williamyeh/wrk \
            -t4 -c100 -d30s \
            --latency \
            http://localhost:8080/tiles/demo_out/14/100_100.jpg 2>&1 | tee -a $RESULTS_FILE || true
        fi

        # Collect server timing breakdown
        echo "" >> $RESULTS_FILE
        echo "=== Server Timing Breakdown ===" | tee -a $RESULTS_FILE
        docker logs origami-server-${{ matrix.arch }} 2>&1 | grep -E "total_family_gen_ms|l2_decode_ms|parallel_chroma_ms|l0_resize_ms|l0_residual_ms" | tail -20 | tee -a $RESULTS_FILE

        # Check SIMD features
        echo "" >> $RESULTS_FILE
        echo "=== CPU Features ===" | tee -a $RESULTS_FILE
        if [ "${{ matrix.arch }}" = "amd64" ]; then
          docker exec origami-server-${{ matrix.arch }} sh -c "cat /proc/cpuinfo | grep -E 'flags' | head -1 | grep -o -E 'avx2|sse2|sse4_1|sse4_2'" | tr ' ' '\n' | sort -u | tee -a $RESULTS_FILE || echo "Could not detect CPU features" >> $RESULTS_FILE
        elif [ "${{ matrix.arch }}" = "arm64" ]; then
          docker exec origami-server-${{ matrix.arch }} sh -c "cat /proc/cpuinfo | grep -E 'Features' | head -1" | tee -a $RESULTS_FILE || echo "Could not detect CPU features" >> $RESULTS_FILE
        fi

        # Memory usage
        echo "" >> $RESULTS_FILE
        echo "=== Resource Usage ===" | tee -a $RESULTS_FILE
        docker stats --no-stream origami-server-${{ matrix.arch }} | tee -a $RESULTS_FILE

        # Cleanup
        docker stop origami-server-${{ matrix.arch }}
        docker rm origami-server-${{ matrix.arch }}

        # Final summary
        echo "" >> $RESULTS_FILE
        echo "=== Test Completed Successfully ===" | tee -a $RESULTS_FILE

    - name: Upload performance results
      uses: actions/upload-artifact@v3
      with:
        name: perf-results-${{ matrix.arch }}
        path: |
          perf-*.txt
        retention-days: 7

  deploy:
    name: Deploy to Production
    needs: [test-native, build-multi-arch, benchmark]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'

    steps:
    - name: Deploy notification
      run: |
        echo "Ready to deploy ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest"
        # Add your deployment steps here (K8s, ECS, etc.)