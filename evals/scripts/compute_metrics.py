#!/usr/bin/env python3
"""Compute visual quality metrics for Rust encoder runs.

Reads original and reconstructed tile PNGs from compress/ and decompress/
directories (generated by `origami encode --debug-images`) and computes
PSNR, SSIM, MSE, VIF, Delta E, LPIPS. Updates the manifest.json in-place.

Usage:
    uv run python evals/scripts/compute_metrics.py [run_dirs...]

If no run_dirs given, processes all rs_* runs in evals/runs/.
"""

import argparse
import json
import pathlib
import sys
import re

import numpy as np
from PIL import Image
from skimage.metrics import peak_signal_noise_ratio as psnr
from skimage.metrics import structural_similarity as ssim
from skimage.color import rgb2lab, deltaE_cie76

try:
    from sewar.full_ref import vifp
    HAS_VIF = True
except ImportError:
    HAS_VIF = False

try:
    import torch
    import lpips as lpips_lib
    _lpips_net = None
    HAS_LPIPS = True
except ImportError:
    HAS_LPIPS = False


def calculate_mse(a, b):
    return float(np.mean((a.astype(np.float32) - b.astype(np.float32)) ** 2))


def calculate_vif(img1, img2):
    if not HAS_VIF:
        return None
    try:
        if img1.ndim == 2:
            img1 = np.stack([img1]*3, axis=-1)
            img2 = np.stack([img2]*3, axis=-1)
        return float(vifp(img1, img2))
    except Exception:
        return None


def calculate_delta_e(img1, img2):
    try:
        lab1 = rgb2lab(img1.astype(np.float64) / 255.0)
        lab2 = rgb2lab(img2.astype(np.float64) / 255.0)
        return float(np.mean(deltaE_cie76(lab1, lab2)))
    except Exception:
        return None


def calculate_lpips(img1, img2):
    if not HAS_LPIPS:
        return None
    global _lpips_net
    try:
        if _lpips_net is None:
            _lpips_net = lpips_lib.LPIPS(net='alex')
        t1 = torch.from_numpy(img1.astype(np.float32) / 255.0).permute(2, 0, 1).unsqueeze(0) * 2 - 1
        t2 = torch.from_numpy(img2.astype(np.float32) / 255.0).permute(2, 0, 1).unsqueeze(0) * 2 - 1
        with torch.no_grad():
            return float(_lpips_net(t1, t2).item())
    except Exception:
        return None


def find_file(directory, pattern):
    """Find a file matching pattern (with any numeric prefix)."""
    for f in sorted(directory.iterdir()):
        if re.search(pattern, f.name):
            return f
    return None


def compute_tile_metrics(original_rgb, reconstructed_rgb):
    """Compute all metrics between original and reconstructed RGB tiles."""
    metrics = {}

    # PSNR on luminance
    y_orig = 0.299 * original_rgb[:,:,0].astype(np.float32) + \
             0.587 * original_rgb[:,:,1].astype(np.float32) + \
             0.114 * original_rgb[:,:,2].astype(np.float32)
    y_recon = 0.299 * reconstructed_rgb[:,:,0].astype(np.float32) + \
              0.587 * reconstructed_rgb[:,:,1].astype(np.float32) + \
              0.114 * reconstructed_rgb[:,:,2].astype(np.float32)

    metrics["final_psnr"] = float(psnr(y_orig, y_recon, data_range=255))
    metrics["final_ssim"] = float(ssim(y_orig, y_recon, data_range=255))
    metrics["final_mse"] = calculate_mse(original_rgb, reconstructed_rgb)

    vif_val = calculate_vif(original_rgb, reconstructed_rgb)
    if vif_val is not None:
        metrics["final_vif"] = vif_val

    delta_e = calculate_delta_e(original_rgb, reconstructed_rgb)
    if delta_e is not None:
        metrics["final_delta_e"] = delta_e

    lpips_val = calculate_lpips(original_rgb, reconstructed_rgb)
    if lpips_val is not None:
        metrics["final_lpips"] = lpips_val

    return metrics


def process_run(run_dir):
    """Process a single Rust encoder run, computing metrics from debug images."""
    run_dir = pathlib.Path(run_dir)
    manifest_path = run_dir / "manifest.json"
    compress_dir = run_dir / "compress"
    decompress_dir = run_dir / "decompress"

    if not manifest_path.exists():
        print(f"  Skipping {run_dir.name}: no manifest.json")
        return
    if not compress_dir.exists() or not decompress_dir.exists():
        print(f"  Skipping {run_dir.name}: no compress/ or decompress/ dirs")
        return

    with open(manifest_path) as f:
        manifest = json.load(f)

    # Only process Rust manifests (have tiles[] array)
    if not isinstance(manifest.get("tiles"), list):
        print(f"  Skipping {run_dir.name}: not a Rust manifest")
        return

    print(f"  Processing {run_dir.name}...")

    # Build decompression_phase structure matching Python format
    decompression = {"L1": {}, "L0": {}}

    for tile_info in manifest["tiles"]:
        level = tile_info["level"]
        tx = tile_info["tx"]
        ty = tile_info["ty"]
        tile_key = f"tile_{tx}_{ty}"

        # Find original and reconstructed images
        orig_pattern = f"_{level}_{tx}_{ty}_original\\.png$"
        recon_pattern = f"_{level}_{tx}_{ty}_reconstructed\\.png$"

        orig_file = find_file(compress_dir, orig_pattern)
        recon_file = find_file(decompress_dir, recon_pattern)

        if orig_file is None or recon_file is None:
            print(f"    Missing images for {level} ({tx},{ty})")
            continue

        original = np.array(Image.open(orig_file).convert("RGB"))
        reconstructed = np.array(Image.open(recon_file).convert("RGB"))

        metrics = compute_tile_metrics(original, reconstructed)
        decompression[level][tile_key] = metrics

    # Add decompression_phase to manifest
    manifest["decompression_phase"] = decompression

    # Also add size_comparison for viewer compatibility
    l2_bytes = manifest.get("l2_bytes", 0)
    l1_res = sum(t["residual_bytes"] for t in manifest["tiles"] if t["level"] == "L1")
    l0_res = sum(t["residual_bytes"] for t in manifest["tiles"] if t["level"] == "L0")
    manifest["size_comparison"] = {
        "origami_total": l2_bytes + l1_res + l0_res,
        "origami_L2_baseline": l2_bytes,
        "origami_L1_residuals": l1_res,
        "origami_L0_residuals": l0_res,
    }

    with open(manifest_path, 'w') as f:
        json.dump(manifest, f, indent=2)

    # Print summary
    all_psnr = []
    all_ssim = []
    for level in ["L1", "L0"]:
        for tk, td in decompression[level].items():
            if "final_psnr" in td:
                all_psnr.append(td["final_psnr"])
            if "final_ssim" in td:
                all_ssim.append(td["final_ssim"])

    avg_psnr = np.mean(all_psnr) if all_psnr else 0
    avg_ssim = np.mean(all_ssim) if all_ssim else 0
    print(f"    {len(all_psnr)} tiles: avg PSNR={avg_psnr:.2f} dB, avg SSIM={avg_ssim:.4f}")


def main():
    parser = argparse.ArgumentParser(description="Compute visual metrics for Rust encoder runs")
    parser.add_argument("runs", nargs="*", help="Run directories to process (default: all rs_* in evals/runs/)")
    args = parser.parse_args()

    if args.runs:
        run_dirs = [pathlib.Path(r) for r in args.runs]
    else:
        runs_dir = pathlib.Path("evals/runs")
        run_dirs = sorted(d for d in runs_dir.iterdir()
                         if d.is_dir() and d.name.startswith("rs_"))

    if not run_dirs:
        print("No runs found to process.")
        return

    print(f"Computing metrics for {len(run_dirs)} run(s)...")
    if not HAS_VIF:
        print("  (VIF unavailable — install sewar)")
    if not HAS_LPIPS:
        print("  (LPIPS unavailable — install lpips + torch)")

    for run_dir in run_dirs:
        process_run(run_dir)

    print("\nDone.")


if __name__ == "__main__":
    main()
